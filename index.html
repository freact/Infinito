<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Infinito Board Game</title>
    <style>
        body { font-family: sans-serif; display: flex; flex-direction: column; align-items: center; background: #f0f0f0; }
        #game-container { display: flex; gap: 20px; margin-top: 20px; }
        #board { display: grid; grid-template-columns: repeat(6, 50px); grid-template-rows: repeat(6, 50px); gap: 2px; background: #444; border: 4px solid #444; }
        .cell { width: 50px; height: 50px; background: #fff; display: flex; align-items: center; justify-content: center; font-weight: bold; cursor: pointer; position: relative; }
        .cell.highlight { background: #e0ffe0; }
        .cell.selected { background: #ffffa0; }
        .stone { width: 40px; height: 40px; border-radius: 50%; display: flex; align-items: center; justify-content: center; color: white; border: 2px solid #333; }
        .stone.white { background: #fff; color: #000; }
        .stone.black { background: #000; color: #fff; }
        .stone.neutral { background: #888; color: #eee; }
        #ui { width: 250px; }
        .status-box { padding: 10px; background: white; border: 1px solid #ccc; border-radius: 4px; }
        .btn { margin-top: 10px; padding: 10px; width: 100%; cursor: pointer; background: #eee; border: 1px solid #999; }
        .btn:hover { background: #ddd; }
        .supply-val { font-size: 1.2em; font-weight: bold; color: #007bff; }
    </style>
</head>
<body>

    <h1>Infinito</h1>
    <div id="game-container">
        <div id="board"></div>
        
        <div id="ui">
            <div class="status-box">
                <p>Turn: <strong id="current-player">Black</strong></p>
                <p>Phase: <span id="game-phase">Optional Move</span></p>
                <p>Next to place: <span class="supply-val" id="next-val">0</span></p>
                <p>Penalty removals due: <strong id="penalty-count">0</strong></p>
            </div>
            <button class="btn" id="skip-move">Skip Move Phase</button>
            <div style="margin-top: 15px;">
                <p>Black Sum: <span id="black-score">0</span></p>
                <p>White Sum: <span id="white-score">0</span></p>
            </div>
        </div>
    </div>

<script>
const SIZE = 6;
const boardElement = document.getElementById('board');
const phaseText = document.getElementById('game-phase');
const playerText = document.getElementById('current-player');
const nextValText = document.getElementById('next-val');
const penaltyText = document.getElementById('penalty-count');

let board = Array(SIZE).fill(null).map(() => Array(SIZE).fill(null));
let currentPlayer = 'black'; // 'black' or 'white'
let phase = 'MOVE'; // 'MOVE', 'REMOVING', 'PLACE'
let selectedStone = null;
let penaltiesRemaining = 0;
let movedStonePos = null;
let supply = { black: 0, white: 0 };

function initBoard() {
    boardElement.style.gridTemplateColumns = `repeat(${SIZE}, 50px)`;
    render();
}

function getScore(color) {
    let sum = 0;
    board.forEach(row => row.forEach(cell => {
        if (cell && cell.owner === color) sum += cell.val;
    }));
    return sum;
}

function checkPenalty(r, c, movedStone) {
    let penaltyCount = 0;
    const enemy = movedStone.owner === 'black' ? 'white' : 'black';
    
    for (let dr = -1; dr <= 1; dr++) {
        for (let dc = -1; dc <= 1; dc++) {
            if (dr === 0 && dc === 0) continue;
            let nr = r + dr, nc = c + dc;
            if (nr >= 0 && nr < SIZE && nc >= 0 && nc < SIZE) {
                let target = board[nr][nc];
                if (target && target.owner === enemy && target.val < movedStone.val) {
                    // Check if they WERE adjacent before (not strictly required by rule logic here, 
                    // but we assume any move that lands next to a smaller enemy counts)
                    penaltyCount++;
                }
            }
        }
    }
    return penaltyCount;
}

function handleCellClick(r, c) {
    const cell = board[r][c];

    if (phase === 'MOVE') {
        if (selectedStone) {
            // Try to move
            if (!cell && isValidQueenMove(selectedStone.r, selectedStone.c, r, c)) {
                const stone = board[selectedStone.r][selectedStone.c];
                board[selectedStone.r][selectedStone.c] = null;
                board[r][c] = stone;
                
                penaltiesRemaining = checkPenalty(r, c, stone);
                movedStonePos = {r, c};

                if (penaltiesRemaining > 0) {
                    phase = 'REMOVING';
                } else {
                    phase = 'PLACE';
                }
                selectedStone = null;
            } else {
                selectedStone = null;
            }
        } else if (cell && cell.owner === currentPlayer) {
            selectedStone = {r, c};
        }
    } 
    else if (phase === 'REMOVING') {
        // Must replace one of YOUR OWN stones (not the one just moved)
        if (cell && cell.owner === currentPlayer && (r !== movedStonePos.r || c !== movedStonePos.c)) {
            board[r][c] = { owner: 'neutral', val: 'âˆž' };
            penaltiesRemaining--;
            if (penaltiesRemaining <= 0) phase = 'PLACE';
        }
    } 
    else if (phase === 'PLACE') {
        if (!cell) {
            board[r][c] = { owner: currentPlayer, val: supply[currentPlayer]++ };
            endTurn();
        }
    }
    render();
}

function isValidQueenMove(r1, c1, r2, c2) {
    const dr = Math.abs(r1 - r2);
    const dc = Math.abs(c1 - c2);
    if (dr !== 0 && dc !== 0 && dr !== dc) return false;
    
    // Check path obstruction
    const stepR = r1 === r2 ? 0 : (r2 > r1 ? 1 : -1);
    const stepC = c1 === c2 ? 0 : (c2 > c1 ? 1 : -1);
    let curR = r1 + stepR;
    let curC = c1 + stepC;
    while (curR !== r2 || curC !== c2) {
        if (board[curR][curC]) return false;
        curR += stepR;
        curC += stepC;
    }
    return true;
}

function endTurn() {
    currentPlayer = currentPlayer === 'black' ? 'white' : 'black';
    phase = 'MOVE';
    // Check if board full
    if (board.flat().every(cell => cell !== null)) {
        alert(`Game Over! Black: ${getScore('black')}, White: ${getScore('white')}`);
    }
}

function render() {
    boardElement.innerHTML = '';
    for (let r = 0; r < SIZE; r++) {
        for (let c = 0; c < SIZE; c++) {
            const cellDiv = document.createElement('div');
            cellDiv.className = 'cell';
            if (selectedStone && selectedStone.r === r && selectedStone.c === c) cellDiv.classList.add('selected');
            
            const piece = board[r][c];
            if (piece) {
                const stoneDiv = document.createElement('div');
                stoneDiv.className = `stone ${piece.owner}`;
                stoneDiv.innerText = piece.val;
                cellDiv.appendChild(stoneDiv);
            }
            cellDiv.onclick = () => handleCellClick(r, c);
            boardElement.appendChild(cellDiv);
        }
    }
    
    playerText.innerText = currentPlayer.charAt(0).toUpperCase() + currentPlayer.slice(1);
    phaseText.innerText = phase;
    nextValText.innerText = supply[currentPlayer];
    penaltyText.innerText = penaltiesRemaining;
    document.getElementById('black-score').innerText = getScore('black');
    document.getElementById('white-score').innerText = getScore('white');
}

document.getElementById('skip-move').onclick = () => {
    if (phase === 'MOVE') {
        phase = 'PLACE';
        selectedStone = null;
        render();
    }
};

initBoard();
</script>
</body>
</html>
